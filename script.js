// ---------- Cookie Helpers ----------
function setCookie(name, value, days) {
  let expires = "";
  if (days) {
    const date = new Date();
    date.setTime(date.getTime() + days * 24 * 60 * 60 * 1000);
    expires = "; expires=" + date.toUTCString();
  }
  document.cookie = name + "=" + encodeURIComponent(value) + expires + "; path=/";
}

function getCookie(name) {
  const cookies = document.cookie.split("; ");
  for (let c of cookies) {
    const [key, value] = c.split("=");
    if (key === name) return decodeURIComponent(value);
  }
  return "";
}

function deleteCookie(name) {
  document.cookie = name + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
}

// ---------- Style Functions ----------
function toCursive(text) {
  const map = {
    a: "ùí∂", b: "ùí∑", c: "ùí∏", d: "ùíπ", e: "‚ÑØ", f: "ùíª", g: "‚Ñä", h: "ùíΩ",
    i: "ùíæ", j: "ùíø", k: "ùìÄ", l: "ùìÅ", m: "ùìÇ", n: "ùìÉ", o: "‚Ñ¥", p: "ùìÖ",
    q: "ùìÜ", r: "ùìá", s: "ùìà", t: "ùìâ", u: "ùìä", v: "ùìã", w: "ùìå", x: "ùìç",
    y: "ùìé", z: "ùìè",
    A: "ùíú", B: "‚Ñ¨", C: "ùíû", D: "ùíü", E: "‚Ñ∞", F: "‚Ñ±", G: "ùí¢", H: "‚Ñã",
    I: "‚Ñê", J: "ùí•", K: "ùí¶", L: "‚Ñí", M: "‚Ñ≥", N: "ùí©", O: "ùí™", P: "ùí´",
    Q: "ùí¨", R: "‚Ñõ", S: "ùíÆ", T: "ùíØ", U: "ùí∞", V: "ùí±", W: "ùí≤", X: "ùí≥",
    Y: "ùí¥", Z: "ùíµ"
  };
  return text.split("").map(ch => map[ch] || ch).join("");
}

function toGothic(text) {
  const map = {
    a: "ùîû", b: "ùîü", c: "ùî†", d: "ùî°", e: "ùî¢", f: "ùî£", g: "ùî§", h: "ùî•",
    i: "ùî¶", j: "ùîß", k: "ùî®", l: "ùî©", m: "ùî™", n: "ùî´", o: "ùî¨", p: "ùî≠",
    q: "ùîÆ", r: "ùîØ", s: "ùî∞", t: "ùî±", u: "ùî≤", v: "ùî≥", w: "ùî¥", x: "ùîµ",
    y: "ùî∂", z: "ùî∑",
    A: "ùîÑ", B: "ùîÖ", C: "‚Ñ≠", D: "ùîá", E: "ùîà", F: "ùîâ", G: "ùîä", H: "‚Ñå",
    I: "‚Ñë", J: "ùîç", K: "ùîé", L: "ùîè", M: "ùîê", N: "ùîë", O: "ùîí", P: "ùîì",
    Q: "ùîî", R: "‚Ñú", S: "ùîñ", T: "ùîó", U: "ùîò", V: "ùîô", W: "ùîö", X: "ùîõ",
    Y: "ùîú", Z: "‚Ñ®"
  };
  return text.split("").map(ch => map[ch] || ch).join("");
}

function toCurlyWrap(text) {
  return text.split("").map(ch => `‚ä∞${ch}‚ä±`).join("");
}

function toDoubleStruck(text) {
  const map = {
    a: "ùïí", b: "ùïì", c: "ùïî", d: "ùïï", e: "ùïñ", f: "ùïó", g: "ùïò", h: "ùïô",
    i: "ùïö", j: "ùïõ", k: "ùïú", l: "ùïù", m: "ùïû", n: "ùïü", o: "ùï†", p: "ùï°",
    q: "ùï¢", r: "ùï£", s: "ùï§", t: "ùï•", u: "ùï¶", v: "ùïß", w: "ùï®", x: "ùï©",
    y: "ùï™", z: "ùï´",
    A: "ùî∏", B: "ùîπ", C: "‚ÑÇ", D: "ùîª", E: "ùîº", F: "ùîΩ", G: "ùîæ", H: "‚Ñç",
    I: "ùïÄ", J: "ùïÅ", K: "ùïÇ", L: "ùïÉ", M: "ùïÑ", N: "‚Ñï", O: "ùïÜ", P: "‚Ñô",
    Q: "‚Ñö", R: "‚Ñù", S: "ùïä", T: "ùïã", U: "ùïå", V: "ùïç", W: "ùïé", X: "ùïè",
    Y: "ùïê", Z: "‚Ñ§"
  };
  return text.split("").map(ch => map[ch] || ch).join("");
}


function toSmallCaps(text) {
  const map = {
    a: "·¥Ä", b: " ô", c: "·¥Ñ", d: "·¥Ö", e: "·¥á", f: "“ì", g: "…¢", h: " ú",
    i: "…™", j: "·¥ä", k: "·¥ã", l: " ü", m: "·¥ç", n: "…¥", o: "·¥è", p: "·¥ò",
    q: "«´", r: " Ä", s: "s", t: "·¥õ", u: "·¥ú", v: "·¥†", w: "·¥°", x: "x",
    y: " è", z: "·¥¢",
    A: "·¥Ä", B: " ô", C: "·¥Ñ", D: "·¥Ö", E: "·¥á", F: "“ì", G: "…¢", H: " ú",
    I: "…™", J: "·¥ä", K: "·¥ã", L: " ü", M: "·¥ç", N: "…¥", O: "·¥è", P: "·¥ò",
    Q: "«´", R: " Ä", S: "s", T: "·¥õ", U: "·¥ú", V: "·¥†", W: "·¥°", X: "x",
    Y: " è", Z: "·¥¢"
  };
  return text.split("").map(ch => map[ch] || ch).join("");
}
function toBubble(text) {
  const map = {
    a:"‚ìê", b:"‚ìë", c:"‚ìí", d:"‚ìì", e:"‚ìî", f:"‚ìï", g:"‚ìñ", h:"‚ìó",
    i:"‚ìò", j:"‚ìô", k:"‚ìö", l:"‚ìõ", m:"‚ìú", n:"‚ìù", o:"‚ìû", p:"‚ìü",
    q:"‚ì†", r:"‚ì°", s:"‚ì¢", t:"‚ì£", u:"‚ì§", v:"‚ì•", w:"‚ì¶", x:"‚ìß",
    y:"‚ì®", z:"‚ì©",
    A:"‚í∂", B:"‚í∑", C:"‚í∏", D:"‚íπ", E:"‚í∫", F:"‚íª", G:"‚íº", H:"‚íΩ",
    I:"‚íæ", J:"‚íø", K:"‚ìÄ", L:"‚ìÅ", M:"‚ìÇ", N:"‚ìÉ", O:"‚ìÑ", P:"‚ìÖ",
    Q:"‚ìÜ", R:"‚ìá", S:"‚ìà", T:"‚ìâ", U:"‚ìä", V:"‚ìã", W:"‚ìå", X:"‚ìç",
    Y:"‚ìé", Z:"‚ìè",
   
    "0":"‚ì™", "1":"‚ë†", "2":"‚ë°", "3":"‚ë¢", "4":"‚ë£",
    "5":"‚ë§", "6":"‚ë•", "7":"‚ë¶", "8":"‚ëß", "9":"‚ë®"
  };
  return text.split("").map(ch => map[ch] || ch).join("");
}

function toCurrency(text) {
  const map = {
    a:"‚Ç≥", b:"‡∏ø", c:"‚Çµ", d:"ƒê", e:"…Ü", f:"‚Ç£", g:"‚Ç≤", h:"‚±ß",
    i:"≈Ç", j:"J", k:"‚Ç≠", l:"‚±†", m:"‚Ç•", n:"‚Ç¶", o:"√ò", p:"‚Ç±",
    q:"Q", r:"‚±§", s:"‚Ç¥", t:"‚ÇÆ", u:"…Ñ", v:"V", w:"‚Ç©", x:"”æ",
    y:"…é", z:"‚±´",
    A:"‚Ç≥", B:"‡∏ø", C:"‚Çµ", D:"ƒê", E:"…Ü", F:"‚Ç£", G:"‚Ç≤", H:"‚±ß",
    I:"≈Ç", J:"J", K:"‚Ç≠", L:"‚±†", M:"‚Ç•", N:"‚Ç¶", O:"√ò", P:"‚Ç±",
    Q:"Q", R:"‚±§", S:"‚Ç¥", T:"‚ÇÆ", U:"…Ñ", V:"V", W:"‚Ç©", X:"”æ",
    Y:"…é", Z:"‚±´"
  };
  return text.split("").map(ch => map[ch] || ch).join("");
}
function toFantasy(text) {
  const map = {
    a:"Í™ñ", b:"Í™â", c:"·®∂", d:"·¶î", e:"Í´Ä", f:"·†ª", g:"·¶ã", h:"Í´ù",
    i:"·ªâ", j:"·ßí", k:"∆ô", l:"Í™∂", m:"Í™ë", n:"·≠¢", o:"Í™Æ", p:"·©è",
    q:"·ßÅ", r:"Í™π", s:"‡∞ï", t:"·°∂", u:"Í™ä", v:"Í™ú", w:"·≠ô", x:"·•ä",
    y:"Í™ó", z:"…Ä",
    A:"Í™ñ", B:"Í™â", C:"·®∂", D:"·¶î", E:"Í´Ä", F:"·†ª", G:"·¶ã", H:"Í´ù",
    I:"·ªâ", J:"·ßí", K:"∆ô", L:"Í™∂", M:"Í™ë", N:"·≠¢", O:"Í™Æ", P:"·©è",
    Q:"·ßÅ", R:"Í™π", S:"‡∞ï", T:"·°∂", U:"Í™ä", V:"Í™ú", W:"·≠ô", X:"·•ä",
    Y:"Í™ó", Z:"…Ä"
  };
  return text.split("").map(ch => map[ch] || ch).join("");
}
function toRusify(text) {
  const map = {
    a:"–∞", b:"–±", c:"c", d:"–¥", e:"—ë", f:"f", g:"g", h:"–Ω",
    i:"—ó", j:"j", k:"–∫", l:"–≥", m:"—´", n:"–ø", o:"—≥", p:"p",
    q:"—Ñ", r:"—è", s:"$", t:"—Ç", u:"—Ü", v:"—µ", w:"—â", x:"–∂",
    y:"—á", z:"–∑",
    A:"–ê", B:"–ë", C:"C", D:"–î", E:"–Ñ", F:"F", G:"G", H:"H",
    I:"–á", J:"J", K:"–ö", L:"–ì", M:"—™", N:"–ô", O:"—≤", P:"P",
    Q:"–§", R:"–Ø", S:"$", T:"T", U:"–¶", V:"—¥", W:"–®", X:"–ñ",
    Y:"–ß", Z:"–ó"
  };
  return text.split("").map(ch => map[ch] || ch).join("");
}
function toMonospace(text) {
  const map = {
    a:"ùöä", b:"ùöã", c:"ùöå", d:"ùöç", e:"ùöé", f:"ùöè", g:"ùöê", h:"ùöë",
    i:"ùöí", j:"ùöì", k:"ùöî", l:"ùöï", m:"ùöñ", n:"ùöó", o:"ùöò", p:"ùöô",
    q:"ùöö", r:"ùöõ", s:"ùöú", t:"ùöù", u:"ùöû", v:"ùöü", w:"ùö†", x:"ùö°",
    y:"ùö¢", z:"ùö£",
    A:"ùô∞", B:"ùô±", C:"ùô≤", D:"ùô≥", E:"ùô¥", F:"ùôµ", G:"ùô∂", H:"ùô∑",
    I:"ùô∏", J:"ùôπ", K:"ùô∫", L:"ùôª", M:"ùôº", N:"ùôΩ", O:"ùôæ", P:"ùôø",
    Q:"ùöÄ", R:"ùöÅ", S:"ùöÇ", T:"ùöÉ", U:"ùöÑ", V:"ùöÖ", W:"ùöÜ", X:"ùöá",
    Y:"ùöà", Z:"ùöâ"
  };
  return text.split("").map(ch => map[ch] || ch).join("");
}
function toSquare(text) {
  const map = {
    A:"üÑ∞", B:"üÑ±", C:"üÑ≤", D:"üÑ≥", E:"üÑ¥", F:"üÑµ", G:"üÑ∂", H:"üÑ∑",
    I:"üÑ∏", J:"üÑπ", K:"üÑ∫", L:"üÑª", M:"üÑº", N:"üÑΩ", O:"üÑæ", P:"üÑø",
    Q:"üÖÄ", R:"üÖÅ", S:"üÖÇ", T:"üÖÉ", U:"üÖÑ", V:"üÖÖ", W:"üÖÜ", X:"üÖá",
    Y:"üÖà", Z:"üÖâ",
    a:"üÑ∞", b:"üÑ±", c:"üÑ≤", d:"üÑ≥", e:"üÑ¥", f:"üÑµ", g:"üÑ∂", h:"üÑ∑",
    i:"üÑ∏", j:"üÑπ", k:"üÑ∫", l:"üÑª", m:"üÑº", n:"üÑΩ", o:"üÑæ", p:"üÑø",
    q:"üÖÄ", r:"üÖÅ", s:"üÖÇ", t:"üÖÉ", u:"üÖÑ", v:"üÖÖ", w:"üÖÜ", x:"üÖá",
    y:"üÖà", z:"üÖâ"
  };
  return text.split("").map(ch => map[ch] || ch).join("");
}
function toInfinite(text) {
  return text.split("").map(ch => {
    if (/[a-zA-Z]/.test(ch)) {
      return ch + "Õö"; // add combining underline
    }
    return ch;
  }).join(" ");
}
function toCrypticItalic(text) {
  const map = {
    a: "êåÄ", b: "êåÅ", c: "êåÇ", d: "êåÉ", e: "êåÑ", f: "êåÖ", g: "·èµ", h: "êãÖ",
    i: "êåâ", j: "·èù", k: "êåä", l: "êåã", m: "êåå", n: "êåç", o: "Íùä", p: "êåê",
    q: "êåí", r: "êåì", s: "êåî", t: "êåï", u: "êåµ", v: "·ïì", w: "·èî", x: "êãÑ",
    y: "êåô", z: "‚±ø",

    A: "êåÄ", B: "êåÅ", C: "êåÇ", D: "êåÉ", E: "êåÑ", F: "êåÖ", G: "·èµ", H: "êãÖ",
    I: "êåâ", J: "·èù", K: "êåä", L: "êåã", M: "êåå", N: "êåç", O: "Íùä", P: "êåê",
    Q: "êåí", R: "êåì", S: "êåî", T: "êåï", U: "êåµ", V: "·ïì", W: "·èî", X: "êãÑ",
    Y: "êåô", Z: "‚±ø"
  };
  return text.split("").map(ch => map[ch] || ch).join("");
}
function toParenthesis(text) {
  const map = {
    a: "‚íú", b: "‚íù", c: "‚íû", d: "‚íü", e: "‚í†", f: "‚í°", g: "‚í¢", h: "‚í£",
    i: "‚í§", j: "‚í•", k: "‚í¶", l: "‚íß", m: "‚í®", n: "‚í©", o: "‚í™", p: "‚í´",
    q: "‚í¨", r: "‚í≠", s: "‚íÆ", t: "‚íØ", u: "‚í∞", v: "‚í±", w: "‚í≤", x: "‚í≥",
    y: "‚í¥", z: "‚íµ",

    A: "‚íú", B: "‚íù", C: "‚íû", D: "‚íü", E: "‚í†", F: "‚í°", G: "‚í¢", H: "‚í£",
    I: "‚í§", J: "‚í•", K: "‚í¶", L: "‚íß", M: "‚í®", N: "‚í©", O: "‚í™", P: "‚í´",
    Q: "‚í¨", R: "‚í≠", S: "‚íÆ", T: "‚íØ", U: "‚í∞", V: "‚í±", W: "‚í≤", X: "‚í≥",
    Y: "‚í¥", Z: "‚íµ"
  };
  return text.split("").map(ch => map[ch] || ch).join("");
}
function toJapanese(text) {
  const map = {
    a: "ÂçÇ", b: "‰πÉ", c: "Âåö", d: "·ó™", e: "‰πá", f: "ÂçÉ", g: "·é∂", h: "ÂçÑ",
    i: "‰∏®", j: "Ôæå", k: "“ú", l: "„Ñ•", m: "Áà™", n: "Âá†", o: "„Ññ", p: "Âç©",
    q: "…ä", r: "Â∞∫", s: "‰∏Ç", t: "„Ñí", u: "„Ñ©", v: "·êØ", w: "Â±±", x: "‰πÇ",
    y: "„Ñö", z: "‰πô",

    A: "ÂçÇ", B: "‰πÉ", C: "Âåö", D: "·ó™", E: "‰πá", F: "ÂçÉ", G: "·é∂", H: "ÂçÑ",
    I: "‰∏®", J: "Ôæå", K: "“ú", L: "„Ñ•", M: "Áà™", N: "Âá†", O: "„Ññ", P: "Âç©",
    Q: "…ä", R: "Â∞∫", S: "‰∏Ç", T: "„Ñí", U: "„Ñ©", V: "·êØ", W: "Â±±", X: "‰πÇ",
    Y: "„Ñö", Z: "‰πô"
  };
  return text.split("").map(ch => map[ch] || ch).join("");
}
// Love Emojis Inverted Style
function toLoveInverted(text) {
  const map = {
    a: "…ê", b: "q", c: "…î", d: "p", e: "«ù", f: "…ü", g: "∆É", h: "…•",
    i: "ƒ±", j: "…æ", k: " û", l: "◊ü", m: "…Ø", n: "u", o: "o", p: "d",
    q: "b", r: "…π", s: "s", t: " á", u: "n", v: " å", w: " ç", x: "x",
    y: " é", z: "z",

    A: "‚àÄ", B: "·ó∫", C: "∆Ü", D: "·ó°", E: "∆é", F: "‚Ñ≤", G: "‚ÖÅ", H: "H",
    I: "I", J: "≈ø", K: "Íìò", L: "À•", M: "W", N: "N", O: "O", P: "‘Ä",
    Q: "·É¢", R: "·¥ö", S: "S", T: "‚ä•", U: "‚à©", V: "Œõ", W: "M", X: "X",
    Y: "‚ÖÑ", Z: "Z"
  };

  return "üòçüíûüíò " + text.split("").map(ch => map[ch] || ch).join("") + " üíîüíèüíñ";
}
function toFraktur(text) {
  const map = {
    a: "ùñÜ", b: "ùñá", c: "ùñà", d: "ùñâ", e: "ùñä", f: "ùñã", g: "ùñå", h: "ùñç",
    i: "ùñé", j: "ùñè", k: "ùñê", l: "ùñë", m: "ùñí", n: "ùñì", o: "ùñî", p: "ùñï",
    q: "ùññ", r: "ùñó", s: "ùñò", t: "ùñô", u: "ùñö", v: "ùñõ", w: "ùñú", x: "ùñù",
    y: "ùñû", z: "ùñü",

    A: "ùï¨", B: "ùï≠", C: "ùïÆ", D: "ùïØ", E: "ùï∞", F: "ùï±", G: "ùï≤", H: "ùï≥",
    I: "ùï¥", J: "ùïµ", K: "ùï∂", L: "ùï∑", M: "ùï∏", N: "ùïπ", O: "ùï∫", P: "ùïª",
    Q: "ùïº", R: "ùïΩ", S: "ùïæ", T: "ùïø", U: "ùñÄ", V: "ùñÅ", W: "ùñÇ", X: "ùñÉ",
    Y: "ùñÑ", Z: "ùñÖ"
  };
  return text.split("").map(ch => map[ch] || ch).join("");
}
function toWide(text) {
  const map = {
    a: "ÔΩÅ", b: "ÔΩÇ", c: "ÔΩÉ", d: "ÔΩÑ", e: "ÔΩÖ", f: "ÔΩÜ", g: "ÔΩá", h: "ÔΩà",
    i: "ÔΩâ", j: "ÔΩä", k: "ÔΩã", l: "ÔΩå", m: "ÔΩç", n: "ÔΩé", o: "ÔΩè", p: "ÔΩê",
    q: "ÔΩë", r: "ÔΩí", s: "ÔΩì", t: "ÔΩî", u: "ÔΩï", v: "ÔΩñ", w: "ÔΩó", x: "ÔΩò",
    y: "ÔΩô", z: "ÔΩö",

    A: "Ôº°", B: "Ôº¢", C: "Ôº£", D: "Ôº§", E: "Ôº•", F: "Ôº¶", G: "Ôºß", H: "Ôº®",
    I: "Ôº©", J: "Ôº™", K: "Ôº´", L: "Ôº¨", M: "Ôº≠", N: "ÔºÆ", O: "ÔºØ", P: "Ôº∞",
    Q: "Ôº±", R: "Ôº≤", S: "Ôº≥", T: "Ôº¥", U: "Ôºµ", V: "Ôº∂", W: "Ôº∑", X: "Ôº∏",
    Y: "Ôºπ", Z: "Ôº∫"
  };
  return text.split("").map(ch => map[ch] || ch).join(" ");
}
function toSkyBlue(text) {
  const map = {
    a: "üá¶", b: "üáß", c: "üá®", d: "üá©", e: "üá™", f: "üá´", g: "üá¨", h: "üá≠",
    i: "üáÆ", j: "üáØ", k: "üá∞", l: "üá±", m: "üá≤", n: "üá≥", o: "üá¥", p: "üáµ",
    q: "üá∂", r: "üá∑", s: "üá∏", t: "üáπ", u: "üá∫", v: "üáª", w: "üáº", x: "üáΩ",
    y: "üáæ", z: "üáø",

    A: "üá¶", B: "üáß", C: "üá®", D: "üá©", E: "üá™", F: "üá´", G: "üá¨", H: "üá≠",
    I: "üáÆ", J: "üáØ", K: "üá∞", L: "üá±", M: "üá≤", N: "üá≥", O: "üá¥", P: "üáµ",
    Q: "üá∂", R: "üá∑", S: "üá∏", T: "üáπ", U: "üá∫", V: "üáª", W: "üáº", X: "üáΩ",
    Y: "üáæ", Z: "üáø"
  };
  return text.split("").map(ch => map[ch] || ch).join(" ");
}
// Inverted Squares (Negative Squared Latin Capital Letters)
function toInvertedSquares(text) {
  const map = {
    A:"üÖ∞", B:"üÖ±", C:"üÖ≤", D:"üÖ≥", E:"üÖ¥", F:"üÖµ", G:"üÖ∂", H:"üÖ∑",
    I:"üÖ∏", J:"üÖπ", K:"üÖ∫", L:"üÖª", M:"üÖº", N:"üÖΩ", O:"üÖæ", P:"üÖø",
    Q:"üÜÄ", R:"üÜÅ", S:"üÜÇ", T:"üÜÉ", U:"üÜÑ", V:"üÜÖ", W:"üÜÜ", X:"üÜá",
    Y:"üÜà", Z:"üÜâ",
    a:"üÖ∞", b:"üÖ±", c:"üÖ≤", d:"üÖ≥", e:"üÖ¥", f:"üÖµ", g:"üÖ∂", h:"üÖ∑",
    i:"üÖ∏", j:"üÖπ", k:"üÖ∫", l:"üÖª", m:"üÖº", n:"üÖΩ", o:"üÖæ", p:"üÖø",
    q:"üÜÄ", r:"üÜÅ", s:"üÜÇ", t:"üÜÉ", u:"üÜÑ", v:"üÜÖ", w:"üÜÜ", x:"üÜá",
    y:"üÜà", z:"üÜâ"
  };
  return text.split("").map(ch => map[ch] || ch).join(" ");
}
// Luni Tools Style
function toLuniTools(text) {
  const map = {
    A: "∆∏", B: "·ô†", C: "∆Ü", D: "·ó°", E: "∆é", F: "Íüª", G: "·éÆ", H: "H",
    I: "I", J: "·Ç±", K: "‚ãä", L: "‚ÖÉ", M: "M", N: "Õ∂", O: "O", P: "Íüº",
    Q: "·ªå", R: "–Ø", S: "ÍôÑ", T: "T", U: "U", V: "V", W: "W", X: "X",
    Y: "Y", Z: "∆π",

    a: "…í", b: "d", c: "…î", d: "b", e: "…ò", f: "·é∏", g: "«´", h: " ú",
    i: "i", j: "ÍûÅ", k: " û", l: "|", m: "m", n: "·¥é", o: "o", p: "q",
    q: "p", r: "…ø", s: "ÍôÖ", t: "∆ö", u: "u", v: "v", w: "w", x: "x",
    y: " è", z: "∆π"
  };
  return text.split("").map(ch => map[ch] || ch).join("");
}

// ---------- Update Outputs ----------
/**
 * Updates the styled output elements.
 * If text is provided, it applies the style to the text.
 * If text is empty, it shows the default styled words.
 */
function updateOutputs(text) {
  // Cursive
  const cursiveEl = document.getElementById("CursiveOutput");
  if (cursiveEl) {
    cursiveEl.textContent = text ? toCursive(text) : "ùíûùìäùìáùìàùíæùìã‚ÑØ";
  }

  // Gothic
  const gothicEl = document.getElementById("GothicOutput");
  if (gothicEl) {
    gothicEl.textContent = text ? toGothic(text) : "ùîäùî¨ùî±ùî•ùî¶ùî†";
  }

  // Curly Wrap
  const curlyEl = document.getElementById("CurlyOutput");
  if (curlyEl) {
    curlyEl.textContent = text ? toCurlyWrap(text) : "‚ä∞C‚ä±‚ä∞u‚ä±‚ä∞r‚ä±‚ä∞l‚ä±‚ä∞y‚ä± ‚ä∞W‚ä±‚ä∞r‚ä±‚ä∞a‚ä±‚ä∞p‚ä±";
  }

  const doubleEl = document.getElementById("DoubleOutput");
  if (doubleEl) {
    doubleEl.textContent = text ? toDoubleStruck(text) : "ùîªùï†ùï¶ùïìùïùùïñ ùïäùï•ùï£ùï¶ùïîùïú";
  }
  // Small Caps
const smallCapsEl = document.getElementById("SmallCapsOutput");
if (smallCapsEl) {
  smallCapsEl.textContent = text ? toSmallCaps(text) : "S·¥ç·¥Ä ü ü C·¥Ä·¥òs";
}

const bubbleEl = document.getElementById("BubbleOutput");
if (bubbleEl) {
  bubbleEl.textContent = text ? toBubble(text) : "‚í∑‚ì§‚ìë‚ìë‚ìõ‚ìî";
}

const currencyEl = document.getElementById("CurrencyOutput");
if (currencyEl) {
  currencyEl.textContent = text ? toCurrency(text) : "‚Çµ…Ñ‚±§‚±§…Ü‚Ç¶‚Çµ…é";
}
const fantasyEl = document.getElementById("FantasyOutput");
if (fantasyEl) {
  fantasyEl.textContent = text ? toFantasy(text) : "Í™ôÍ´ÄÍ™π·®∂Í™äÍ™ó";
}
const rusifyEl = document.getElementById("RusifyOutput");
if (rusifyEl) {
  rusifyEl.textContent = text ? toRusify(text) : "–Ø—Ü—ï—ñf—É";
}
const monoEl = document.getElementById("MonospaceOutput");
if (monoEl) {
  monoEl.textContent = text ? toMonospace(text) : "ùôºùöòùöóùöòùöúùöôùöäùöåùöé";
}
const squareEl = document.getElementById("SquareOutput");
if (squareEl) {
  squareEl.textContent = text ? toSquare(text) : "üÖÇüÖÄüÖÑüÑ∞üÖÅüÑ¥";
}
const infiniteEl = document.getElementById("InfiniteOutput");
if (infiniteEl) {
  infiniteEl.textContent = text ? toInfinite(text) : toInfinite("Infinite");
}
const crypticEl = document.getElementById("CrypticOutput");
if (crypticEl) {
  crypticEl.textContent = text ? toCrypticItalic(text) : toCrypticItalic("Cryptic Italic");
}

const parenthesisEl = document.getElementById("ParenthesisOutput");
if (parenthesisEl) {
  parenthesisEl.textContent = text ? toParenthesis(text) : toParenthesis("Parenthesis");
}
const japaneseEl = document.getElementById("JapaneseOutput");
if (japaneseEl) {
  japaneseEl.textContent = text ? toJapanese(text) : toJapanese("Japanese");
}
const loveInvEl = document.getElementById("LoveInvertedOutput");
if (loveInvEl) {
  loveInvEl.textContent = text ? toLoveInverted(text) : toLoveInverted("Love Inverted");
}
const frakturEl = document.getElementById("FrakturOutput");
if (frakturEl) {
  frakturEl.textContent = text ? toFraktur(text) : toFraktur("Fraktur");
}
const wideEl = document.getElementById("WideOutput");
if (wideEl) {
  wideEl.textContent = text ? toWide(text) : toWide("Wide");
}
const skyBlueEl = document.getElementById("SkyBlueOutput");
if (skyBlueEl) {
  skyBlueEl.textContent = text ? toSkyBlue(text) : toSkyBlue("Sky Blue");
}

// Inverted Squares
const invertedSquaresEl = document.getElementById("InvertedSquaresOutput");
if (invertedSquaresEl) {
  invertedSquaresEl.textContent = text ? toInvertedSquares(text) : toInvertedSquares("Inverted");
}
// Luni Tools
const luniEl = document.getElementById("LuniToolsOutput");
if (luniEl) {
  luniEl.textContent = text ? toLuniTools(text) : toLuniTools("Luni Tools");
}

}

// ---------- Input Handling ----------
/**
 * Handles the input event on the text field.
 * Updates styles based on user input or placeholder text.
 */
function handleInputChange() {
  const input = document.getElementById("userInput");
  if (!input) return;

  const value = input.value; // No trim here, to allow spaces
  const clearBtn = document.querySelector(".clear-btn");

  if (value) {
    // If there is text in the input, style it
    setCookie("fontInput", value, 7);
    updateOutputs(value);
    if (clearBtn) clearBtn.style.display = "inline";
  } else {
    // If input is empty, revert to styling the placeholder
    deleteCookie("fontInput");
    const placeholderText = input.getAttribute("placeholder");

    if (placeholderText && placeholderText !== "Type something...") {
      // It's a custom placeholder, so style it
      updateOutputs(placeholderText);
    } else {
      // It's the default placeholder, show default styled text
      updateOutputs("");
    }
    if (clearBtn) clearBtn.style.display = "none";
  }
}

/**
 * Clears the input field and resets the view.
 */
function clearInput() {
  const input = document.getElementById("userInput");
  if (input) {
    input.value = "";
  }
  // Trigger the input change handler to reset the state correctly
  handleInputChange();
}

// ---------- Copy Handling ----------
// ---------- Copy Handling ----------
function copyToClipboard(id) {
  const el = document.getElementById(id);
  if (!el) return;

  // Get the styled text content directly from the element
  const styledText = el.textContent;

  navigator.clipboard.writeText(styledText).then(() => {
    const note = document.getElementById("copyNotification");
    if (note) {
      // Update the notification text with the actual styled text
      note.textContent = styledText + " Copied!";
      note.style.display = "block";
      setTimeout(() => {
        note.style.display = "none";
      }, 1500);
    }
  });
}

// Auto-inject SVG icons into all copy buttons
function addCopyIcons() {
  document.querySelectorAll(".copy-btn").forEach(btn => {
    if (!btn.innerHTML.trim()) {
      btn.innerHTML = `
       <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18"
             viewBox="0 0 24 24" fill="none" stroke="currentColor"
             stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
          <path d="M5 15H4a2 2 0 0 1-2-2V4
                   a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
        </svg>`;
    }
  });
}

// ---------- On Page Load ----------
/**
 * Initializes the page state when the content is loaded.
 * It checks for saved cookies or custom placeholders to set the initial text style.
 */
window.addEventListener("DOMContentLoaded", () => {
  const saved = getCookie("fontInput");
  const input = document.getElementById("userInput");
  const clearBtn = document.querySelector(".clear-btn");

  if (input) {
    // This logic runs for pages that have the main input box
    if (saved) {
      // If a cookie exists, prioritize it
      input.value = saved;
      updateOutputs(saved);
      if (clearBtn) clearBtn.style.display = "inline";
    } else {
      // If no cookie, check the placeholder
      const placeholderText = input.getAttribute("placeholder");
      if (placeholderText && placeholderText !== "Type something...") {
        // Style the custom placeholder text
        updateOutputs(placeholderText);
      } else {
        // Show default styled text
        updateOutputs("");
      }
      if (clearBtn) clearBtn.style.display = "none";
    }
  } else {
    // This is a fallback for pages without an input box
    if (saved) {
      updateOutputs(saved);
    }
  }

  addCopyIcons();
});

  window.addEventListener("scroll", () => {
    const searchBox = document.getElementById("searchSection");
    if (window.scrollY > 30) {
      searchBox.classList.add("shrink");
    } else {
      searchBox.classList.remove("shrink");
    }
  });

  /* Add to your existing JavaScript file */

/**
 * Checks if the navigation tabs are overflowing and shows/hides scroll buttons.
 */
function checkTabOverflow() {
  const tabNav = document.getElementById("tabNav");
  const scrollLeftBtn = document.getElementById("scrollLeftBtn");
  const scrollRightBtn = document.getElementById("scrollRightBtn");
  const tabWrapper = document.querySelector(".tab-wrapper");

  if (!tabNav || !scrollLeftBtn || !scrollRightBtn || !tabWrapper) return;

  const isOverflowing = tabNav.scrollWidth > tabNav.clientWidth;

  if (isOverflowing) {
    tabWrapper.classList.add("has-buttons");
    scrollRightBtn.classList.add("show");
  } else {
    tabWrapper.classList.remove("has-buttons");
    scrollLeftBtn.classList.remove("show");
    scrollRightBtn.classList.remove("show");
  }

  // Update button visibility based on scroll position
  if (isOverflowing) {
    // Hide left button if at the start
    if (tabNav.scrollLeft === 0) {
      scrollLeftBtn.classList.remove("show");
    } else {
      scrollLeftBtn.classList.add("show");
    }

    // Hide right button if at the end
    if (tabNav.scrollLeft + tabNav.clientWidth >= tabNav.scrollWidth - 1) { // -1 for a small buffer
      scrollRightBtn.classList.remove("show");
    } else {
      scrollRightBtn.classList.add("show");
    }
  }
}

/**
 * Scrolls the tab navigation left or right.
 * @param {string} direction - "left" or "right"
 */
function scrollTabs(direction) {
  const tabNav = document.getElementById("tabNav");
  const scrollAmount = tabNav.clientWidth / 2; // Scroll half a viewport
  if (direction === "left") {
    tabNav.scrollBy({ left: -scrollAmount, behavior: "smooth" });
  } else if (direction === "right") {
    tabNav.scrollBy({ left: scrollAmount, behavior: "smooth" });
  }
}

// Add event listeners
window.addEventListener("resize", checkTabOverflow);
window.addEventListener("DOMContentLoaded", () => {
  // Existing DOMContentLoaded logic
  // ... (your existing code) ...
  
  // Add new logic for buttons
  checkTabOverflow();
  const tabNav = document.getElementById("tabNav");
  const scrollLeftBtn = document.getElementById("scrollLeftBtn");
  const scrollRightBtn = document.getElementById("scrollRightBtn");

  if (tabNav) {
    tabNav.addEventListener("scroll", checkTabOverflow);
  }
  
  if (scrollLeftBtn) {
    scrollLeftBtn.addEventListener("click", () => scrollTabs("left"));
  }
  
  if (scrollRightBtn) {
    scrollRightBtn.addEventListener("click", () => scrollTabs("right"));
  }
});



// navbar, backtotop
 const backToTopBtn = document.getElementById('backToTopBtn');

    window.onscroll = function () {
      if (document.body.scrollTop > 200 || document.documentElement.scrollTop > 200) {
        backToTopBtn.style.display = 'flex';
      } else {
        backToTopBtn.style.display = 'none';
      }
    };

    function scrollToTop() {
      window.scrollTo({
        top: 0,
        behavior: 'smooth'
      });
    }


  


    // Elements
    const navMenu = document.getElementById('navMenu');
    const navOverlay = document.getElementById('navOverlay');
    const menuToggleBtn = document.getElementById('menuToggle');
    const stickyInputWrap = document.getElementById('stickyInputWrap');
    const dropdowns = navMenu.querySelectorAll('.dropdown > .dropdown-toggle');

    // Open/Close menu (mobile)
    menuToggleBtn.addEventListener('click', function() {
      const isOpen = navMenu.classList.contains('open');
      if (!isOpen) {
        navMenu.classList.add('open');
        navOverlay.classList.add('active');
        menuToggleBtn.classList.add('open');
        document.body.style.overflow = 'hidden';
      } else {
        navMenu.classList.remove('open');
        navOverlay.classList.remove('active');
        menuToggleBtn.classList.remove('open');
        document.body.style.overflow = '';
        navMenu.querySelectorAll('.dropdown').forEach(dd => dd.classList.remove('open'));
      }
    });

    navOverlay.addEventListener('click', function() {
      navMenu.classList.remove('open');
      navOverlay.classList.remove('active');
      menuToggleBtn.classList.remove('open');
      document.body.style.overflow = '';
      navMenu.querySelectorAll('.dropdown').forEach(dd => dd.classList.remove('open'));
    });

    // Close menu on outside click (for mobile)
    document.addEventListener('mousedown', function(e) {
      if (window.innerWidth < 900 && navMenu.classList.contains('open')) {
        if (!navMenu.contains(e.target) && !menuToggleBtn.contains(e.target)) {
          navMenu.classList.remove('open');
          navOverlay.classList.remove('active');
          menuToggleBtn.classList.remove('open');
          document.body.style.overflow = '';
          navMenu.querySelectorAll('.dropdown').forEach(dd => dd.classList.remove('open'));
        }
      }
    });

    // Dropdown toggle
    dropdowns.forEach(drop => {
      drop.addEventListener('click', function(e) {
        e.preventDefault();
        const parent = this.parentElement;
        const isOpen = parent.classList.contains('open');
        navMenu.querySelectorAll('.dropdown').forEach(dd => dd.classList.remove('open'));
        if (!isOpen) parent.classList.add('open');
      });
    });

    // Close dropdowns when clicking outside (desktop)
    document.addEventListener('mousedown', function(e) {
      if (window.innerWidth >= 900) {
        navMenu.querySelectorAll('.dropdown').forEach(dd => {
          if (!dd.contains(e.target)) dd.classList.remove('open');
        });
      }
    });

    // Ensure sticky input is always below nav and dropdown
    function adjustStickyInput() {
      let offset = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--nav-height'));
      // Only add dropdown height on mobile (where dropdown pushes content)
      if (window.innerWidth < 900) {
        const openDropdown = navMenu.querySelector('.dropdown.open .dropdown-content');
        if (openDropdown) {
          offset += openDropdown.offsetHeight;
        }
      }
      stickyInputWrap.style.top = offset + 'px';
    }
    navMenu.addEventListener('transitionend', adjustStickyInput);
    window.addEventListener('resize', adjustStickyInput);
    navMenu.addEventListener('click', adjustStickyInput);
    adjustStickyInput();

